<!DOCTYPE html>


<html lang="en-us" data-theme="">
<head>
    
        
<meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer-when-downgrade">

<title>Win32 System Programming - Part 5 - Cihat Yildiz</title>

<meta name="description" content="Islemcilerin Sayfalama Mekanizmasi      Modern guclu masaustu islemcileri ve guclu mobil islemciler sayfalama (paging) mekanizmasina sahiptir. Bu sistemde fiziksel RAM sayfa denilen bloklara ayrilmistir. Sayfa uzunluklari sistemden sisteme degisebilir. INTEL de 4K (4096 Byte) tir. Bu durumda ornegin bellegin n numarali sayfasi n*4096 inci byte den baslan ve 4096 byte surer Islemci sayfa tablosu (page table) denilen bir tabloya bakarak calisir.. Program icerisinde kullandigimiz adresler gercek fiziksel ram de yer belirtmez.">



<link rel="icon" type="image/x-icon" href="https://www.cihatyildiz.com/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="https://www.cihatyildiz.com/favicon.png">



    





    
    
        
    
    

    
        <link rel="stylesheet" href="https://www.cihatyildiz.com/css/style.min.0a537f3bb0e983fac9fdd9ab89517b7c25e24c3e34d140b76e8ae7a11ab74cb1.css" integrity="sha256-ClN/O7Dpg/rJ/dmriVF7fCXiTD400UC3bornoRq3TLE=">
    





    

    





    
    
        
    
    

    
        <script src="https://www.cihatyildiz.com/js/script.min.a65afe903825231554d9b55b073eb144da4ccf2d2823b216dcbc6cc656c9de76.js" type="text/javascript" charset="utf-8" integrity="sha256-plr&#43;kDglIxVU2bVbBz6xRNpMzy0oI7IW3LxsxlbJ3nY="></script>
    







<meta property="og:title" content="Win32 System Programming - Part 5" />
<meta property="og:description" content="Islemcilerin Sayfalama Mekanizmasi      Modern guclu masaustu islemcileri ve guclu mobil islemciler sayfalama (paging) mekanizmasina sahiptir. Bu sistemde fiziksel RAM sayfa denilen bloklara ayrilmistir. Sayfa uzunluklari sistemden sisteme degisebilir. INTEL de 4K (4096 Byte) tir. Bu durumda ornegin bellegin n numarali sayfasi n*4096 inci byte den baslan ve 4096 byte surer Islemci sayfa tablosu (page table) denilen bir tabloya bakarak calisir.. Program icerisinde kullandigimiz adresler gercek fiziksel ram de yer belirtmez." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.cihatyildiz.com/post/2014-09-22-win32-system-prog-part5/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2014-09-29T20:55:00+08:00" />
<meta property="article:modified_time" content="2014-09-29T20:55:00+08:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Win32 System Programming - Part 5"/>
<meta name="twitter:description" content="Islemcilerin Sayfalama Mekanizmasi      Modern guclu masaustu islemcileri ve guclu mobil islemciler sayfalama (paging) mekanizmasina sahiptir. Bu sistemde fiziksel RAM sayfa denilen bloklara ayrilmistir. Sayfa uzunluklari sistemden sisteme degisebilir. INTEL de 4K (4096 Byte) tir. Bu durumda ornegin bellegin n numarali sayfasi n*4096 inci byte den baslan ve 4096 byte surer Islemci sayfa tablosu (page table) denilen bir tabloya bakarak calisir.. Program icerisinde kullandigimiz adresler gercek fiziksel ram de yer belirtmez."/>











    
</head>
<body>
    <a class="skip-main" href="#main">Skip to main content</a>
    <div class="container">
        <header class="common-header"> 
            
                <div class="header-top">
    <h1 class="site-title">
        <a href="/"><strong>Cihat Yildiz</strong></a>
    </h1>
    <ul class="social-icons">


    
        <li>
            <a href="https://twitter.com/cihatix" title="Twitter" rel="me">
            <span class="inline-svg" >




    
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>

</span>

            </a>
        </li>
    

    
        <li>
            <a href="https://www.linkedin.com/in/cihatyildiz/" title="Linkedin" rel="me">
            <span class="inline-svg" >




    
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>

</span>

            </a>
        </li>
    

    
        <li>
            <a href="https://github.com/mitrichius/hugo-theme-anubis" title="Github" rel="me">
            <span class="inline-svg" >




    
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>

</span>

            </a>
        </li>
    



    
    <li>
        <a href="/index.xml" title="RSS" rel="me">
        <span class="inline-svg" >




    
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg>

</span>

        </a>
    </li>


</ul>
</div>

    <nav>
        
        
        <a class="" href="https://www.cihatyildiz.com/about/" title="">About</a>
        
        <a class="" href="https://www.cihatyildiz.com/projects/" title="">Projects</a>
        
        <a class="" href="https://www.cihatyildiz.com/trainings/" title="">Trainings</a>
        
        <a class="" href="https://www.cihatyildiz.com/posts/" title="">Archive</a>
        
        <a class="" href="https://www.cihatyildiz.com/tags/" title="">Tags</a>
        
    </nav>




            
        </header>
        <main id="main" tabindex="-1"> 
            
    

    <article class="post h-entry">
        <div class="post-header">
            <header>
                <h1 class="p-name post-title">Win32 System Programming - Part 5</h1>

                
            </header>
        </div>
        <div class="content e-content">
            <h2 id="islemcilerin-sayfalama-mekanizmasi" >Islemcilerin Sayfalama Mekanizmasi
<span>
    <a href="#islemcilerin-sayfalama-mekanizmasi">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h2><ul>
<li>Modern guclu masaustu islemcileri ve guclu mobil islemciler sayfalama (paging) mekanizmasina sahiptir.</li>
<li>Bu sistemde fiziksel RAM sayfa denilen bloklara ayrilmistir. Sayfa uzunluklari sistemden sisteme degisebilir.</li>
<li>INTEL de 4K (4096 Byte) tir. Bu durumda ornegin bellegin n numarali sayfasi n*4096 inci byte den baslan ve 4096 byte surer</li>
<li>Islemci sayfa tablosu (page table) denilen bir tabloya bakarak calisir..</li>
<li>Program icerisinde kullandigimiz adresler gercek fiziksel ram de yer belirtmez. Bunlara sanal adres denir. Sayfa tablosu sanal adresleri fiziksel adreslere sayfa temelinde donusturmektedir.</li>
<li>Her processin ayri bir sayfa tablosu olmaktadir.</li>
<li>Ornek bir satfa tablosu soyle olabilir.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">a</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#ae81ff">10</span><span style="color:#75715e">;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">b</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#ae81ff">20</span><span style="color:#75715e">;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MOV</span> [<span style="color:#ae81ff">2629652</span>], <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MOV</span> [<span style="color:#ae81ff">0009652</span>], <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Sanal</span> <span style="color:#66d9ef">sayfa</span> <span style="color:#66d9ef">no</span>  <span style="color:#66d9ef">Fiziksel</span> <span style="color:#66d9ef">sayfa</span> <span style="color:#66d9ef">no</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">0</span>  <span style="color:#960050;background-color:#1e0010">302</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">1</span>  <span style="color:#960050;background-color:#1e0010">512</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">..</span>  <span style="color:#66d9ef">..</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">..</span>  <span style="color:#66d9ef">..</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">642</span>  <span style="color:#960050;background-color:#1e0010">715</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">643</span>  <span style="color:#960050;background-color:#1e0010">819</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">..</span>  <span style="color:#66d9ef">..</span>
</span></span></code></pre></div><p>Ornegin islemci programi isletirken decimal olarak 2629652 numarali adresle karsilasmis olsun. Once islemci bunun kacinci sanal sayfada oldugunu hesaplar. Sonra bu sanal sayfanin kacinci ofsetinde oldugunda hesaplar. b adresi 4096 ya bolersek (12 kere shift) sanal sayfa numarasini bolumunden elde edilen kalan ise ofset numarasini verir. Islemci bundan sonra 642 inci sanal sayfanin sayfa tablosunda hangi fiziksel sayfaya yonlendirildigini bulur ve offseti ona ekleyerek gercek fiziksel adresi elde eder. Goruldugu gibi programin sanal adres alani ardisil oldugu halde fiziksel alani ardisil olmak zorunda degildir. Multi processing calismada isletim sistemi her process icin ayri bir sayfa tablosu olusturur. Ve processler arasi gecis olustugunda islemcinin baktigi sayfa tablosu da degistirilir. Sayfa tablolarini isletim sistemi olusturur ve isletim sistemi bu tablolardaki fiziksel tablolari cakistirmazsa proseslerin bellek alanlari tamamen izole edilmis olur. Yani iki farkli processdeki iki sanal adres aslinda fiziksel ram de tamamen farkli yerler belirtebilir. Boyle bir sistemde bir process istese bile digerinin bellek alanina zaten erisemez.</p>
<pre tabindex="0"><code>swap in
swap out
page falt
</code></pre><p>Sayfalama mekanizma sayesinde de sanal bellek mekanizmasi da aktif hale getirilmektedir. Sanal bellek Programlarin yalnizca bir bolumunun fiziksel ram a yuklenerek disk ile ram arasinda yer degistirmeli olarak calistirmasina denir. Islemci bir mantiksal sayfaya bir fiziksel sayfa karsilik getirilmedigini gordugunde icsel bir kesme olusturur. Bu icsel kesmeye intel teminolojisinde page fault denilmektedir. INTEL Terminolojisinde fault denildiginde bir komutun bir problemden dolayi bir kesme olusturdugu, fakat bu kesmede cikilinca islemcinin probleme yol acan komutun kendisi ile devam ettigi dutumlar anlasilmaktadir. Sanal bellek kullanimi sirasinda programin kucuk bir bolumu fiziksel ram a yuklenir. Boylece sayfa tablosunda cok buyuk kisim icin bir fiziksel sayfa numarasi atanmamis olur. Program calisirken kod yada data bakimindan fiziksel karsiligi olmayan bir sanal adrese erisildiginde page fault olusur. Kontrolu isletim sistemi ele alir. Isletim sistemi hangi sanal sayfaya erisildiginden hareketle programin o kismini diskten ceker ve fiziksel sayfaya yukler. sonra sayfa tablosunu duzeltir ve calisma devam eder. Genellikle fiziksek ram tikabasa doldurulmus durumdasdir. bir programin 4K lik bir parcasini fiziksel ramdan bir sayfanin cikartilmasi gerekmektedir. Bu sirada isletim sistemini iyi bir karar vermesi gerekir. En az kullanilan sayfanin cikartilmasi kullanilmasi uygun olur. Eger fiziksel ram dan cikartilacak sayfa update edilmis ise, bu durumda bu sayfayi fiziksel ram dan cikartirken bu sayfayi yeniden diste bir yere yazmak gerekmektedir. Fakat update edilmemis ise yazmaya gerek yoktur. isletim sistemelri genel olarak mumkun oldugunca calistirilabilen dosyanin kendisini swap amacli da kullanmak ister(windows boyle yapar). Fakat update edilmis sayfalar icin ayri bir page dile duzenlemesinin yapilmasi gerekmektedir. Ornegin isletim sistemlerindeki paylasilan bellek alanlari (shared memory) sayfa tablolari ile gerceklestirilir. p1 ve p1 process leri bu bicimde haberlesecek olsunlar. sistem p1 procesinin 917 inci sayfasi ile p2 procesinin 645 inci sayfasini varsayalim ki ayni fiziksel adrese yonlendirebioir. Boylece p1 procesinin 917 sayfaya yazdilarini p2 procesi 645. sayfadan okuyabilir. Copy on write Sanal bellek kullanimindaki onemli kullanimlardan biri de copy in write ozelligidir. Ayni program birden fazla kez calistirildiginda yada bir dll farkli processler tarafindan kullanildiginda isletim sistemi gereksiz bir bicimde bunlari yeniden yeniden fiziksel ram a yuklemez. Baslangicta sayfalari 1 kez yukler. ve her processin sayfa tablosunda ayni sayfalari kullanir. Fakat bir process yazma yaptigi zamana digerlerinin bundan etkilenmemesi gerekir. Bunun icin tipik olarak sayfa ozellikleri read only olarak ayarlanir. boylece bir sayfaya yazma yapildiginda pagefault olusur. isletim sistemi de o sayfanin o an kopkasindan cikartarak paylasilmakta olan fiziksel sayfalari birbirinden ayirir. Boylece sayfalarin bastan degil gerektiginde kopyalari cikartilmis olur. <a href="http://www.kaanaslan.com/resource/article/display">http://www.kaanaslan.com/resource/article/display</a>_article.php?id=87 makalesi okunabilir. Ayni attribute sajip bir veya birden fazla ardisik sayfa topluluguna section denir.</p>
<h2 id="processlerin-haberlesme-yontemleri-inter-process-communication--ipc" >Processlerin Haberlesme yontemleri (Inter Process Communication – IPC)
<span>
    <a href="#processlerin-haberlesme-yontemleri-inter-process-communication--ipc">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h2><p>Processler arasi haberlesme, bir processin diger bir procese bir bayt yigini gondermesi ve digerinin de bunu alarak kullanmasi anlamina gelmektedir.</p>
<pre tabindex="0"><code>Hoca sonra anlatacak.
</code></pre><p>Isletim sisteminin asagi seviyeli disk cache sistemi</p>
<ul>
<li>Cache sistemleri bilgisayar sisteminin cesitli yerinde cesitli amacla kullanilailmektedir. En oneli cache sistemlerinden biri de disk cache sistemidir. Buna ozellikel Unix /Linux dunyasinda “Buffer Cache” de denilmektedir.</li>
<li>Isletim sistemi son erisilen disk bloklarini fiziksel ram da bir cache de tutarak. diske erisimi azaltmak ister.</li>
<li>Boylece bir dosya islemi yapilirken akis kernel moda gecer. Kernel fonksiyonlari okunacak veya yazilacak disk blogunun hangisi olduguna karar verir ve onu once cache de arar. Cache de bulamaz ise blok diskde aranir.</li>
<li>Standart C fonksiyonlarinin uyguladigi cache sistemi. Cache kelime hizlandirma amaci ile kullaniliyor. buffer kelime si de STandart C Fonksiyonlarinin kullandigi cache sistemi</li>
<li>Standart C fonksiyonlari aslinda Jva ve C# dosya siniflari da tamamen boyle davranir, &lt; &gt; bura da cache yerine buffered IO fonksiyonu denlmektedir. Boylece biz bir standar C fonksiyonu ile 1 Byte bile okuyacak olsak. Bu fonksiyon once isletim sisteminin okuma yapan api (windows da readFIle, linux da read) fonksiyonunu cagirir. Oradan bir grup bilgiyi cache e tasir ve diger olumanalari cache den karsilar.</li>
<li>Olusturulan cache read/write bir sistemdir. Yani bilgi yazildiginda cache a yazilir.</li>
<li>Bu cache calisma sirasinda yada en kotu olasilikla dosya kapatilirken. Flash edilmektedir. Fakat programci da istedigi zaman Fflush islemi yapabilir. Aygitlar ve Dosyalar</li>
<li>WIndows sistemlerinde ve UNIX /Linux sistemlerinde aygitlar da birer dosya gibi degerlendirilmelidir. Aygitlari aygit suruculer kontrol eder. Aygit suruculer de dosya fonksiyonlari ile acilip isleme sokulurlar.</li>
<li>Ornegin ekran aslinda bir aygittir ve bir aygit surucu ile erisilir. Biz ilgili aygit surucuyu acip ona writefile api fonksiyonu ile birseyler yapsak, yazdiklarimizi bu aygit surucu ekrana cikartir,</li>
<li>Bu sayede biz aygitlara birer dosyaymis gibi erisiriz ve onlari cok daha basit algilar ve kullaniriz.</li>
<li>Standart C fonksiyonun olusturdugu cache sistemi aygitlar icin de gecerlidir. Yani biz stdout aygitini kullanarak fprintf gibi bir fonksiyon ile ekrana birseyler yazmak istesek aslinda o once tanpona yazilacak. oradan aktarilacaktir.</li>
<li>Konu ile ilgili ayrintili bigiyi <a href="http://www.kaanaslan.com/resource/article/display">http://www.kaanaslan.com/resource/article/display</a>_article.php?page=2&amp;id=83 adresinden okunmali Processlerin Hand Tablosu</li>
<li>Geri donus degeri HANDLE turunden olan kernel tarafindan organize edilen bir grup veri yapisina kernel nesnesi denilmektedir.</li>
<li>Processler , threadler, dosyalar, somaforlar, mutexler birer kernel nesnesidir.</li>
<li>Kernel Nesneleri CreateXxxx ile olusturulur CloseHandle fonksiyonu yok edilir.</li>
<li>Her Processin bir process handle taplosu vardir. Aslinda bir handle processin handle tablosunda bir index belirtir. Gercek nesnenin adresi bu indexdeki elemanda saklanir.</li>
<li>KErnel nesneleri processler arasinda paylasilabilir.
<ol>
<li>Processlerin handler degerleri processe ozgudur ve gorelidir. Yani biz birhandle degeri baska bir perocesse gonderdigimizde o handle degeri ile o process baska bir nesneye erisebilir. yada o handle degeri o process icin anlamli degildir.</li>
<li>Farkli processlerdeki farkli handle degerleri ayni nesneyi gosteriyor olabilir</li>
<li>Threadlerin handle tablosuyoktur processlerin va</li>
<li>cREATE PROCESS islemi sirasinda ust process in process handle tablosu tamamen alt processe aktarilir. Boylece ust process ile alt process ayni handle degerleri ile ayni kernel nesnelerine erisir.</li>
<li>Aslinda ust process create process fonksiyonunu uygularken alt process e handle aktarimini engelleyebilir. Bunun icin create process fonksiyonunun ana salter gorevindeki. bInheritHandles parametresi kullanilir. Ayrica her kernel nesnesinin yaratimi sirasinda o nesnenin alt process e aktarilip aktarilmayacagi da belirlenebilir.</li>
<li>Bu belirleme security attribute parametresi ile yapilir. (Bu parametre NULL gecilebilir o zaman aktarim yapilmaz.)</li>
<li>UNIX / Linux sistemlerinde tamamen benzer bir sistem kullanilmaktadir. Bu sistemlerde process handle tablosu yerine dosya betimleyici tablosu (file dicriptor table) verdir. Handle yerine dosya betimleyicisi (File discriptor table)</li>
</ol>
</li>
</ul>
<h2 id="heading" >###########################
<span>
    <a href="#heading">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h2><ol>
<li>UNIX / Linux sistemlerinde windows sistemlerindeki gibi bir kernel nesnesi kavrami yoktur. (Kernel nesnesi vardir ama process dosya betimleyici tablosu ile ilgili degildir)</li>
<li>Unix / Linux sistemlerinde dosya betimleyici tablosunda yanlizca dosya betimleyicileri vardir. DuplucateHandle Fonksiyonu
<ul>
<li>DuplucateHandle fonksiyonu bir process in process handle tablosundaki bir girisi, yani bir handle degerini parametre olarak alir. O handle degerinin kosterdigi kernel nesnesini gosteren o processde yada baska bir process de yeni bir handle olusturur.</li>
<li>Fonksiyon bizden kaynak process i ve kaynak process deki kopyasi cikartilacak handle degerini parametre olarak alir. Hedef processi de parametre olarak alir. hedef processin process handle tablosunda bir giris olusturur. Olusturulan girisi de bize verir.</li>
<li>O anda calismakta olan kendi processimizin handle degerii GetCurrentProcess api fonksiyonu ile alabiliriz.
<ul>
<li>Bu fonksiyonun verdigi handle process handke tablosunda giris belirtmez ozel bir degerdir. Bu ozel degeri fonksiyonlara verdigimizde fonksiyonlar process handle tablosuna hic bakmazlar. zaten kernel o anda calismakta olan procesi not aldigi icin dogrudan ona giderler.</li>
<li>Suphesiz duplicatehandle ile baska process icin hadle kopyalamasi yaptigimizda o process yeni handle degerini bilmedigi icin kullanamaz. Ayrica bu yeni handle degerini o process e iletmemiz gerekmektedir.</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    DuplicateHandle fonksiyonu ile bir file handle&#39;ın kopyasının çıkarılması
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">-------------------------------------------------------------------------------*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ExitSys</span>(LPCTSTR lpszMsg, <span style="color:#66d9ef">int</span> status);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    HANDLE hFile, hFileDup;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buf[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;This is a test&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buf2[<span style="color:#ae81ff">1024</span>];
</span></span><span style="display:flex;"><span>    DWORD dw;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((hFile <span style="color:#f92672">=</span> CreateFile(<span style="color:#e6db74">&#34;test.dat&#34;</span>, GENERIC_READ<span style="color:#f92672">|</span>GENERIC_WRITE, <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>                        NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) <span style="color:#f92672">==</span> INVALID_HANDLE_VALUE)
</span></span><span style="display:flex;"><span>        ExitSys(<span style="color:#e6db74">&#34;CreateFile&#34;</span>, EXIT_FAILURE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>DuplicateHandle(GetCurrentProcess(), hFile, GetCurrentProcess(),
</span></span><span style="display:flex;"><span>                        <span style="color:#f92672">&amp;</span>hFileDup, <span style="color:#ae81ff">0</span>, FALSE, DUPLICATE_SAME_ACCESS))
</span></span><span style="display:flex;"><span>        ExitSys(<span style="color:#e6db74">&#34;DuplateHandle&#34;</span>, EXIT_FAILURE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    WriteFile(hFile, buf, <span style="color:#66d9ef">sizeof</span>(buf) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>dw, NULL);
</span></span><span style="display:flex;"><span>    SetFilePointer(hFile, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ReadFile(hFileDup, buf2, <span style="color:#ae81ff">1024</span>, <span style="color:#f92672">&amp;</span>dw, NULL))
</span></span><span style="display:flex;"><span>        ExitSys(<span style="color:#e6db74">&#34;ReadFile&#34;</span>, EXIT_FAILURE);
</span></span><span style="display:flex;"><span>    buf2[dw] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>    puts(buf2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    CloseHandle(hFile);
</span></span><span style="display:flex;"><span>    CloseHandle(hFileDup);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ExitSys</span>(LPCTSTR lpszMsg, <span style="color:#66d9ef">int</span> status)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    DWORD dwLastError <span style="color:#f92672">=</span> GetLastError();
</span></span><span style="display:flex;"><span>    LPTSTR lpszErr;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER <span style="color:#f92672">|</span> FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
</span></span><span style="display:flex;"><span>                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) <span style="color:#f92672">&amp;</span>lpszErr, <span style="color:#ae81ff">0</span>, NULL)) {
</span></span><span style="display:flex;"><span>        fprintf(stderr, <span style="color:#e6db74">&#34;%s: %s&#34;</span>, lpszMsg, lpszErr);
</span></span><span style="display:flex;"><span>        LocalFree(lpszErr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    exit(status);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="handle-yonlendirme-islemleri" >Handle Yonlendirme islemleri
<span>
    <a href="#handle-yonlendirme-islemleri">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h3><p>Handle yonlendirme islemi (IO Redirection – IO Yonlendirme) cok sik kullanilan islemlerdir. Bundan amac ozellikle bir alt processin kendini bir dosyaya yazdigini sanirken hedef yonlendirerek onun baska bir yere yazmasini saglamaktir. Ayni sey okuma durumu icin de soz konusudur. UNIX / Linux sistemlerinde her zaman klavyeye iliskin aygitin betimleyicisi 0, ekrana iliskin aygitin betimleyicisi 1 dir. Fakat windows sistemlerinde boyle olmak zorunda degildir. Bu handle degerleri getstdhandle api fonksiyonu ile alinir ve istenirse setstdhandle fonksiyonu ile set edilir. Ornegin Linux sistemlerinde tipik olarak calistiracagimiz bir programin stdout dosyasini bir dosyaya yonlendireceksek sunlar yapilir</p>
<ul>
<li>Ust process for islemi yaparak alt processi yaratir.</li>
<li>Ust process dup2 fonksuyonunu uygulayarak, 1 numarali betimleyicinin acmis oldugu dosyayi gostermesini saylar.</li>
<li>exec islemi uygulayarak yeni programi calistirir. bu isleme IO Redirection denilmektedir. Artik yeni calistirilan programin ekrana yazdiklari ilgili dosyaya yazilmis olur. Cunku ekrana yazan butun fonksiyonlar 1 numarali betimleyiciyi kullanirlar. O da dosya yerine ekrana yazmis olur. Ayni islem windows da soyle yapilmaktadir.</li>
<li>Yonlendirme isleminin yapilacagi dosya createFile fonksiyonu ile yaratilir. Ancak bu dosyanin yaratilirken alt processe aktarilabilirligini saglamak gerekmektedir. (Security attribute = TRUE ve ….. yaparak) set handle information</li>
<li>CreateProcess fonksiyonu ile alt proces yaratilmadan once fonksiyonun startupinfo parametresi uygun bicimde doldurulmalidir. Buradaki startup info yapisi, acilmis olan dosyanin handle ini gosterecek bicimde ayarlanmalidir.</li>
<li>Nihayet createProcess fonksiyonu ile bu startupinfo struct i parametre olarak kullanilarak alt process yaratilir.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*----------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    Windows&#39;ta stdout dosyasının child process&#39;te yönlendirilmesi örneği
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">------------------------------------------------------------------------------*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ExitSys</span>(LPCTSTR lpszMsg, <span style="color:#66d9ef">int</span> status);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    HANDLE hFile;
</span></span><span style="display:flex;"><span>    STARTUPINFO si  <span style="color:#f92672">=</span> {<span style="color:#66d9ef">sizeof</span>(STARTUPINFO)};
</span></span><span style="display:flex;"><span>    PROCESS_INFORMATION pi;
</span></span><span style="display:flex;"><span>    SECURITY_ATTRIBUTES sa <span style="color:#f92672">=</span> {<span style="color:#66d9ef">sizeof</span>(SECURITY_ATTRIBUTES), NULL, TRUE};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> cmdLine[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;E:</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Dropbox</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Tubitak-SGE-Ankara</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Test</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Debug</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Test.exe&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((hFile <span style="color:#f92672">=</span> CreateFile(<span style="color:#e6db74">&#34;test.txt&#34;</span>, GENERIC_WRITE, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>sa, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        ExitSys(<span style="color:#e6db74">&#34;CreateFile&#34;</span>, EXIT_FAILURE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* SetHandleInformation(hFile, HANDLE_FLAG_INHERIT, TRUE);  */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    si.dwFlags <span style="color:#f92672">|=</span> STARTF_USESTDHANDLES;
</span></span><span style="display:flex;"><span>    si.hStdOutput <span style="color:#f92672">=</span> hFile;
</span></span><span style="display:flex;"><span>    si.hStdError <span style="color:#f92672">=</span> hFile;
</span></span><span style="display:flex;"><span>    si.hStdInput <span style="color:#f92672">=</span> GetStdHandle(STD_INPUT_HANDLE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>CreateProcess(NULL, cmdLine, NULL, NULL, TRUE, <span style="color:#ae81ff">0</span>, NULL, NULL, <span style="color:#f92672">&amp;</span>si, <span style="color:#f92672">&amp;</span>pi))
</span></span><span style="display:flex;"><span>        ExitSys(<span style="color:#e6db74">&#34;CreateProcess&#34;</span>, EXIT_FAILURE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    WaitForSingleObject(pi.hProcess, INFINITE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ExitSys</span>(LPCTSTR lpszMsg, <span style="color:#66d9ef">int</span> status)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    DWORD dwLastError <span style="color:#f92672">=</span> GetLastError();
</span></span><span style="display:flex;"><span>    LPTSTR lpszErr;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER <span style="color:#f92672">|</span> FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
</span></span><span style="display:flex;"><span>                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) <span style="color:#f92672">&amp;</span>lpszErr, <span style="color:#ae81ff">0</span>, NULL)) {
</span></span><span style="display:flex;"><span>        fprintf(stderr, <span style="color:#e6db74">&#34;%s: %s&#34;</span>, lpszMsg, lpszErr);
</span></span><span style="display:flex;"><span>        LocalFree(lpszErr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    exit(status);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*------------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        Windows&#39;ta stdout dosyasının child process&#39;te yönlendirilmesi örneği 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        (komut satırı argümanlarıyla)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">------------------------------------------------------------------------------*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ExitSys</span>(LPCTSTR lpszMsg, <span style="color:#66d9ef">int</span> status);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    HANDLE hFile;
</span></span><span style="display:flex;"><span>    STARTUPINFO si  <span style="color:#f92672">=</span> {<span style="color:#66d9ef">sizeof</span>(STARTUPINFO)};
</span></span><span style="display:flex;"><span>    PROCESS_INFORMATION pi;
</span></span><span style="display:flex;"><span>    SECURITY_ATTRIBUTES sa <span style="color:#f92672">=</span> {<span style="color:#66d9ef">sizeof</span>(SECURITY_ATTRIBUTES), NULL, TRUE};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">3</span>) {
</span></span><span style="display:flex;"><span>        fprintf(stderr, <span style="color:#e6db74">&#34;Wrong number of arguments!..</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        exit(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((hFile <span style="color:#f92672">=</span> CreateFile(argv[<span style="color:#ae81ff">2</span>], GENERIC_WRITE, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>sa, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        ExitSys(<span style="color:#e6db74">&#34;CreateFile&#34;</span>, EXIT_FAILURE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* SetHandleInformation(hFile, HANDLE_FLAG_INHERIT, TRUE);  */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    si.dwFlags <span style="color:#f92672">|=</span> STARTF_USESTDHANDLES;
</span></span><span style="display:flex;"><span>    si.hStdOutput <span style="color:#f92672">=</span> hFile;
</span></span><span style="display:flex;"><span>    si.hStdError <span style="color:#f92672">=</span> hFile;
</span></span><span style="display:flex;"><span>    si.hStdInput <span style="color:#f92672">=</span> GetStdHandle(STD_INPUT_HANDLE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>CreateProcess(NULL, argv[<span style="color:#ae81ff">1</span>], NULL, NULL, TRUE, <span style="color:#ae81ff">0</span>, NULL, NULL, <span style="color:#f92672">&amp;</span>si, <span style="color:#f92672">&amp;</span>pi))
</span></span><span style="display:flex;"><span>        ExitSys(<span style="color:#e6db74">&#34;CreateProcess&#34;</span>, EXIT_FAILURE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    WaitForSingleObject(pi.hProcess, INFINITE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ExitSys</span>(LPCTSTR lpszMsg, <span style="color:#66d9ef">int</span> status)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    DWORD dwLastError <span style="color:#f92672">=</span> GetLastError();
</span></span><span style="display:flex;"><span>    LPTSTR lpszErr;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER <span style="color:#f92672">|</span> FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
</span></span><span style="display:flex;"><span>                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) <span style="color:#f92672">&amp;</span>lpszErr, <span style="color:#ae81ff">0</span>, NULL)) {
</span></span><span style="display:flex;"><span>        fprintf(stderr, <span style="color:#e6db74">&#34;%s: %s&#34;</span>, lpszMsg, lpszErr);
</span></span><span style="display:flex;"><span>        LocalFree(lpszErr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    exit(status);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="stderr-dosyasinin-anlami" >STDERR Dosyasinin Anlami
<span>
    <a href="#stderr-dosyasinin-anlami">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h3><p>Programlarin error mesajlari genellikle stderr disyasina yazdirilir. Pekcok sistemde isin basinda default olarak stderr dosyasi da tamamen stdout gibi ekrana yyonlendirilmistir. Fakat daha sonra programci stderrdosyasini baska bir dosyaya vs yonlendirebilir. bBoylece programin hata mesajlari ile normal mesajlarini programi calistiran kisi birbirinden ayirabilir. Hata mesajlarinin her zaman stderr dosyasina yazdirilmasi iyi bir tekniktir.</p>

        </div>
        

    


<div class="post-info">
    
        <div class="post-date dt-published">2014-09-29</div>
    

    <a class="post-hidden-url u-url" href="https://www.cihatyildiz.com/post/2014-09-22-win32-system-prog-part5/">https://www.cihatyildiz.com/post/2014-09-22-win32-system-prog-part5/</a>
    <a href="https://www.cihatyildiz.com" class="p-name p-author post-hidden-author h-card" rel="me">Cihat Yildiz</a>


    <div class="post-taxonomies">
        
            <ul class="post-categories">
                
                    
                    <li><a href="https://www.cihatyildiz.com/categories/notes/">Notes</a></li>
                
            </ul>
            
            
                <ul class="post-tags">
                    
                        
                        <li><a href="https://www.cihatyildiz.com/tags/writing/">#writing</a></li>
                    
                </ul>
        
    </div>
</div>

    </article>

    
        
    <div class="pagination post-pagination">
        <div class="left pagination-item ">
            
                <a href="/post/2014-10-06-linux-system-prog-part1/">Linux System Programming - Part 1</a>
            
        </div>
        <div class="right pagination-item ">
            
                <a href="/post/2014-09-22-win32-system-prog-part4/">Win32 System Programming - Part 4</a>
            
        </div>
    </div>




    

    

    

    


        </main>
        
            <footer class="common-footer">
    
    

    <div class="common-footer-bottom">
        
        <div class="copyright">
            <p>© Cihat Yildiz, 2022<br>
            Powered by <a target="_blank" rel="noopener noreferrer" href="https://gohugo.io/">Hugo</a>, theme <a target="_blank" rel="noopener noreferrer" href="https://github.com/mitrichius/hugo-theme-anubis">Anubis</a>.<br>
            
            </p>  
        </div> 

        

    



    <button class="theme-switcher">
        Dark theme
    </button>

    <script>
    const STORAGE_KEY = 'user-color-scheme'
    const defaultTheme = "auto"

    let currentTheme
    let switchButton
    let autoDefinedScheme = window.matchMedia('(prefers-color-scheme: dark)')

    const autoChangeScheme = e => {
        currentTheme = e.matches ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', currentTheme)
        changeButtonText()
    }

    document.addEventListener('DOMContentLoaded', function() {
        switchButton = document.querySelector('.theme-switcher')
        currentTheme = detectCurrentScheme()
        if (currentTheme == 'dark') {
            document.documentElement.setAttribute('data-theme', 'dark')
        }
        if (currentTheme == 'auto') {
            autoChangeScheme(autoDefinedScheme);
            autoDefinedScheme.addListener(autoChangeScheme);
        }
        changeButtonText()
        switchButton.addEventListener('click', switchTheme, false)
    })

    function detectCurrentScheme() {
        if (localStorage.getItem(STORAGE_KEY)) {
            return localStorage.getItem(STORAGE_KEY)
        } 
        if (defaultTheme) {
            return defaultTheme
        } 
        if (!window.matchMedia) {
            return 'light'
        } 
        if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
            return 'dark'
        }
        return 'light'
    }

    function changeButtonText()
    {   
        switchButton.textContent = currentTheme == 'dark' ?  "Light theme" : "Dark theme"
    }

    function switchTheme(e) {
        if (currentTheme == 'dark') {
            localStorage.setItem(STORAGE_KEY, 'light')
            document.documentElement.setAttribute('data-theme', 'light')
            currentTheme = 'light'
        } else {
            localStorage.setItem(STORAGE_KEY, 'dark')
            document.documentElement.setAttribute('data-theme', 'dark')
            currentTheme = 'dark'
        }
        changeButtonText()
    }
    </script>
   
    </div>

    <p class="h-card vcard">

    <a href=https://www.cihatyildiz.com class="p-name u-url url fn" rel="me">Cihat Yildiz</a> 

    

    
</p> 
</footer>

        
    </div>
</body>
</html>
